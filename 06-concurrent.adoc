== Конкурентное программирование

[quote, Rob Pike]
Concurrency is not parallelism.

Наибольшую популярность язык Go получил благодаря встроенной возможности работы с зелёными потоками, так называемым go-рутинами.

=== Go-рутины

Любой программист, сталкивавшийся с GO слышал, о так называемых go-рутинах и их преимуществах:
- похожи на легковесные потоки
- сравнительно небольшой вес, около 2кб
- возможен запуск большого количества go-рутин

В действительности все эти утверждения верны - поэтому необходимо разобраться детальнее с этим мощным инструментом.

Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.
Горутинами управляет планировщик - является перехватывающим задачи (work-stealing) планировщиком. Изначально был введен еще в Go 1.1. Основная суть работы планировщика заключается в том, что он пытается управлять горутинами Golang, взаимодействовать с потоком ОС и взаимодействовать с ЦП для получения ресурсов системы.
Запустить горутину очень просто:
[source,go]
----
import "fmt"

func VerySimpleFunc(){
  fmt.Println("Hello world")
}

func main() {
  go VerySimpleFunc()
}
----

При вызове `VerySimpleFunc`, ее выполнение происходит асинхронно, относительно выполнения операций в вызвавшем ее потоке.

Важно отметить, что горутины, готовые к исполнению хранятся и выполняются в порядке FIFO(first input, first output). Считается, что горутина готова к исполнению, когда для нее возможно выделить ресурсы системы и место для выполнения, а также имеются права на ее запуск. Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
Как только функция вновь готова к выполнению, она снова попадает в очередь для выполнения.

=== Каналы

Мы познакомились с мощным инструментом - горутины. С другой стороны возникает вопрос, как происходит синхронизация асинхронных действий? Как происходит обмен данными? Для этого в Golang существуют - каналы.

Канал в Golang - это объект связи, позволяющий горутинам обмениваться данными, управлять выполнением. Каналы можно объявить следующим образом:

[source,go]
----
ch1 := make(chan int)            // не буферизированный канал, целых чисел
ch2 := make(chan int, 0)         // не буферизированный канал, целых чисел
ch3 := make(chan *os.File, 100)  // буферизированный канал, указателей на файлы
----

Для передачи данных в канал или, наоборот, из канала применяется операция *<-*. Например, передача данных в канал:

[source,go]
----
ch1 <- 5
----
В данном случае в канал посылается число 5. Получение данных из канала в переменную:

[source,go]
----
someInt := <- ch1
----

Разобравшись с передачей данных. Необходимо понять, как происходит синхронизация выполнения горутин при использовании каналов. Синхронизация гарантируется, тем фактом, что горутина блокируется до того момента, когда из канала будет возможно, чтото прочитать. Иначе говоря, пока канал пустой, горутина не выполняет никаких действий. С другой стороны, отправитель данных в канал тоже блокируется, пока кто либо не прочитает из канала. Такой подход является очень простым и мощным, позволяющим легко управлять потоком выполнения команд. С другой стороны не исключена возможность, блокировки программы, когда выполнение будет заблокировано т.к. писатель и читатель будут заблокированы взаимно.

[source,go]
----
c := make(chan int)  // создание канала
// запускаем, неокторую тяжелую функцию, выполнение которой потребует длительного времени
go func() {
    someHardWork()
    c <- 1  // Отправляем сигнал о завершении
}()
makeSomeGreatWorkToo()
<-c   // ожидаем завершения сортировки
----

Буферизированные каналы в свою очередь позволяют не блокировать писателя, до тех пока не заполнится буфер. Работу буферизированных каналов можно проилюстрировать примером:

[source,go]
----
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1          // Ждем, возможности начать выполнение
    someHardTask(r)   // Ждем, завершения
    <-sem             // Задача завершена, позволяем другим горутинам начать выполнения
}

func MakeAllWork(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)
    }
}

----

Как видно из описанно функции, в данном случае канал позволяет заблокировать асинхронное выполнение задач, когда число единовременно запущенных задач превышает `MaxOutstanding`.

.Однонаправленные каналы

.Возвращение каналов

=== Конкурентный доступ к памяти

Мы уже рассмотрели основной инструмент для управления конкурентного выполнения операций в Golang. С другой стороны конкурентное программирование предполагает возникновение гонок на уровне взаимодействия с памятью. Например, рассмотрим простейшую ситуацию, когда в системе существует N потоков, работающие с одним участком памяти, в котором записано целое число. Каждый поток стремится увеличить это число на некоторую целую величину. Очевидно, что для увеличения числа, необходимо получить его значение и записать новое, увеличенное число. В данном случае нет никакой гарантии, что в итоге в памяти будет записано верное число. Пример такой программы указан ниже:

[source,go]
----
func main() {
  number := 5;
  for i := 0, i < N; i ++ {
    go func(){
      number = number + 5;
    }()
  }
}
----

Для получения верного результата необходимо, что бы доступ к памяти был организован и был последовательным для каждого потока. Для этого в Golang существуют специальные примитивы, позволящие организовать конкурентный доступ к памяти.

==== atomic

В Golang существует пакет `sync/atomic` реализующий в себе наиболее примитивные методы синхронизации. С другой стороны данные методы часто используются для организации других методов синхронизации. Важно отметить, что многие методы пакета используют нативные средства устройств, на которых выполняются, что позволяет обеспечить максимальную производительность. 

Для того, что бы атомарно увеличивать переменную из нашего примера, возможно воспользоваться примитивом из пакета:

[source,go]
----
func main() {
  number := 5;
  for i := 0, i < N; i ++ {
    go func(){
      atomic.AddInt64(&number, 5)
      runtime.Gosched()
    }()
  }
}
----

Использование процедуры `atomic.AddInt64` позволяет запретить потокам, асинхронно работать с этим участком памяти, что в свою очередь позволяет исключить чтение остальными потоками значения переменной, до тех пор, пока поток, который уже выполняет операции с этим участком памяти не запишет результат.

==== mutex 

Мьютексы, безусловно являются неотъемлимой частью программирования, когда речь идет о синхронном доступе к какому либо ресурсу. Исходя из того, что в Golang уже существуют примитивы для атомарных операций с данными в пакете `sync/atomic`, возникает вопрос, о необходимости в использовании данного пакета. Ответ заключается в ограниченном наборе возможностей пакета `sync/atomic`. В случае когда в процессе блокировки требуется выполнить несколько операций, потоку захватившему это состояние и требуются мьютексы. Другими словами мьютексы необходимы в том случае, когда необходимо выполнить синхронно большое количество операций. 

[source, go]
----
var Resource struct {
    locker sync.Mutex // мьютекс, для синхронизации
    position int
}

func (r *Resource) ChangePosition(newPosition int) {
  r.locker.Lock() // блокируем доступ для остальных потоков
  defer r.locker.Unlock() // снимаем блокировку, предоставляем возможность другому потоку захватить управление состоянием
  
  r.position = newPosition // изменение состояния
}

----

Использование мьютекса является простым, но несет в себе необходимость быть осторожным и соблюдать некоторые правила:
- необходимо держать блокировку только необходимое количество времени
- необходимо использовать defer для разблокировки состояния, если не разблоокировать мьютекст все остальные потоки будут в состоянии дедлока

==== Map

=== Ожидание завершения

WaitGroup, ErrGroup

=== Прерывание пула go-рутин

==== Context

==== Вопросы
Какая проблема возникнет при выполнении данного кода?

[source, go]
----
package main

import (
	"fmt"
	"sync"
)

type DataStore struct {
	sync.Mutex // ← этот мьютекс охраняет кэш ниже
	cache      map[string]string
}

func New() *DataStore {
	return &DataStore{
		cache: make(map[string]string),
	}
}

func (ds *DataStore) set(key string, value string) {
	ds.Lock()
	defer ds.Unlock()
	ds.cache[key] = value
}

func (ds *DataStore) get(key string) string {
	ds.Lock()
	defer ds.Unlock()
	if ds.count() > 0 { // <-- count() тоже блокируется!
		item := ds.cache[key]
		return item
	}
	return ""
}

func (ds *DataStore) count() int {
	ds.Lock()
	defer ds.Unlock()
	return len(ds.cache)
}

func main() {
	/* Выполнение кода ниже приведет к дедлоку, так как метод get() заблокируется и метод count() также заблокируется перед тем как get() разблокирует мьютекс
	 */
	store := New()
	store.set("Go", "Lang")
	result := store.get("Go")
	fmt.Println(result)
}
----
